# 状态模式
***
## 设计思想
状态模式的核心是封装，状态的变更引起了行为的变更，从外部看来就好像这个对象对应的类发生了改变一样。

## 适用场景
当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式

***
## 优点
1. 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。
2. 代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中
3. 便于维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产生很多if-else语句，而且容易出错。
4. 扩展性良好。容易增删状态。


## 缺点
1. 状态模式的使用必然会增加系统类和对象的个数。
2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。
3. 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。


***
## 角色介绍
1. Context：环境类，维护一个State子类的实例，这个实例定义当前的状态。
2. State：抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。
3. ConcreteState：具体状态类，每一个子类实现一个与Context的一个状态相关的行为。

## 举例说明
1. 假设有一个电梯，电梯有四种状态：开门状态、关门状态、运行状态、停止状态。电梯的行为有：开门、关门、运行、停止。当电梯处于不同的状态时，电梯的行为也不同。比如，当电梯处于开门状态时，电梯只能关门或者运行，不能再开门或者停止。当电梯处于运行状态时，电梯只能停止，不能再运行、开门或者关门。当电梯处于停止状态时，电梯只能开门或者运行，不能再停止或者关门。当电梯处于关门状态时，电梯只能开门，不能再关门、运行或者停止。
2. App积分抽奖，抽奖有三种状态：可以抽奖、不能抽奖、抽奖结束。抽奖的行为有：扣除积分、抽奖、发放奖品。当抽奖处于可以抽奖状态时，可以扣除积分、抽奖、发放奖品。当抽奖处于不能抽奖状态时，只能扣除积分。当抽奖处于抽奖结束状态时，不能扣除积分、抽奖、发放奖品。

